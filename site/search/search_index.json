{
    "docs": [
        {
            "location": "/", 
            "text": "Myst\n\n\nA language for clarity from the start, flexibility when you need it, and efficiency where it matters.\n\n\ndeftype\n \nList\n\n  \ndef\n \ncontains\n(\nelement\n)\n\n    \neach\n(\nfn\n\n      \n-\n(\nelement\n)\n \n{\n \nbreak\n \ntrue\n \n}\n\n      \n-\n(\n_\n)\n         \n{\n \nfalse\n \n}\n\n    \nend\n)\n\n  \nend\n\n\nend\n\n\n\n[\n1\n,\n \n2\n,\n \n3\n].\ncontains\n(\n2\n)\n \n#=\n true\n\n\n\n\n\n\n\nNotice\n\n\nMyst is still very early on in its development. While the syntax stabilizing, there's still plenty of room for improvement, and even more openness to new ideas.\n\n\nIf you'd like to help shape the language, be an early adopter, or just follow along as things develop, it'd be great to see you in \nour discord server\n or \non GitHub.\n\n\n\n\nIntro\n\n\nMyst is a new programming language with the goal of bridging flexibility and practicality. By directly addressing common traps in modern dynamic programming, Myst provides users the ability to work quickly and easily with the power to write controlled, highly-structured code.\n\n\nWith heavy influences from Ruby, Elixir, Crystal, and other modern languages, Myst combines proven concepts like pattern matching and modular composition with some novel ideas, including global interpolation and fully optional typing. The result is a language that caters to natural thought and logic.\n\n\nSome of the high-level features of Myst include:\n\n\n\n\nPattern-matching everywhere.\n Assignments, method parameters, rescue * clauses, etc.\n\n\nMulti-clause functions.\n All functions can define multiple clauses to adapt functionality based on inputs.\n\n\nValue interpolations.\n Interpolate any value anywhere (even in * method parameters) with the \n syntax.\n\n\nSoft typing.\n Optional type annotations help control functionality without the clutter of conditionals.\n\n\nRaise anything.\n Any value can be raised as an exception and pattern matched by a rescue clause.", 
            "title": "Myst"
        }, 
        {
            "location": "/#myst", 
            "text": "A language for clarity from the start, flexibility when you need it, and efficiency where it matters.  deftype   List \n   def   contains ( element ) \n     each ( fn \n       - ( element )   {   break   true   } \n       - ( _ )           {   false   } \n     end ) \n   end  end  [ 1 ,   2 ,   3 ]. contains ( 2 )   #=  true    Notice  Myst is still very early on in its development. While the syntax stabilizing, there's still plenty of room for improvement, and even more openness to new ideas.  If you'd like to help shape the language, be an early adopter, or just follow along as things develop, it'd be great to see you in  our discord server  or  on GitHub.", 
            "title": "Myst"
        }, 
        {
            "location": "/#intro", 
            "text": "Myst is a new programming language with the goal of bridging flexibility and practicality. By directly addressing common traps in modern dynamic programming, Myst provides users the ability to work quickly and easily with the power to write controlled, highly-structured code.  With heavy influences from Ruby, Elixir, Crystal, and other modern languages, Myst combines proven concepts like pattern matching and modular composition with some novel ideas, including global interpolation and fully optional typing. The result is a language that caters to natural thought and logic.  Some of the high-level features of Myst include:   Pattern-matching everywhere.  Assignments, method parameters, rescue * clauses, etc.  Multi-clause functions.  All functions can define multiple clauses to adapt functionality based on inputs.  Value interpolations.  Interpolate any value anywhere (even in * method parameters) with the   syntax.  Soft typing.  Optional type annotations help control functionality without the clutter of conditionals.  Raise anything.  Any value can be raised as an exception and pattern matched by a rescue clause.", 
            "title": "Intro"
        }, 
        {
            "location": "/basic_operations/", 
            "text": "Basic Operations\n\n\nWith the knowledge of values and how they are managed, let's look at some ways that they can be manipulated.\n\n\nAlmost all of the basic operators are actually defined as methods on the types of objects. For example, the expression \n1 + 2\n calls the + method on the value \n1\n, with \n2\n as an argument. This method-based approach means that these operators can be overridden on any type at any time.\n\n\nThe examples in this section will almost exclusively use literal values to clearly show the types involved in the operations, but all of the operators can be used with variables or sometimes even types or modules instead with the same effects.\n\n\nMathematic operations\n\n\nMost primitive values define the basic arithmetic operations: \n+\n, \n-\n, \n*\n, \n/\n, and \n%\n. Some examples:\n\n\n1\n \n+\n \n1\n       \n#=\n 2\n\n\n2\n.\n6\n \n+\n \n3\n.\n8\n   \n#=\n 6.4\n\n\n10\n \n*\n \n10\n     \n#=\n 100\n\n\n120\n \n%\n \n100\n   \n#=\n 20\n\n\nh\n \n+\n \ni\n   \n#=\n \nhi\n\n\n\n\n\nCollections also implement some operations like \n+\n:\n\n\n[\n1\n,\n \n2\n]\n \n+\n \n[\n3\n,\n \n4\n]\n \n#=\n [1, 2, 3, 4]\n\n\n{\na\n:\n \n1\n}\n \n+\n \n{\nb\n:\n \n2\n}\n \n#=\n {a: 1, b: 2}\n\n\n\n\n\nFor Maps, keys are unique, so adding two Maps that contain the same key will give the key in the result the value of the second Map. For example:\n\n\n{\na\n:\n \n1\n,\n \nb\n:\n \n2\n}\n \n+\n \n{\na\n:\n \n2\n,\n \nc\n:\n \n3\n}\n\n\n#=\n {a: 2, b: 2, c: 3}\n\n\n\n\n\nThis can be useful for quickly applying default values to a Map, but may also lead to some unexpected behavior if it is not understood beforehand.\n\n\nMost value types define a number of other mathematic operations, such as \nString#*\n and \nList#-\n. There are too many to cover comprehensively in this guide, so be sure to check the documentation for a more complete look at the operations that are available.\n\n\nCollection access\n\n\nTo access individual values within a collection, Myst provides \naccess notation\n via square braces (\n[\n and \n]\n) with an index argument between them:\n\n\nlist\n \n=\n \n[\n1\n,\n \n2\n,\n \n3\n]\n\n\nlist\n[\n0\n]\n \n#=\n 1\n\n\nmap\n \n=\n \n{\na\n:\n \n1\n,\n \nb\n:\n \n2\n}\n\n\nmap\n[\n:b\n]\n \n#=\n 2\n\n\n\n\n\nLists use zero-based indexing, meaning the first element of a List is at position \n0\n, and the last element of the List is at position \nn-1\n, where \nn\n is the number of elements in the List.\n\n\nIn a List, the index argument is generally only allowed to be an Integer. For Maps, the index can be any type, but will generally be a Symbol, following the preference that Map keys should use Symbols.\n\n\nIn any case, if the element at the given index does not exist (e.g., the key is not in the Map, of the index is past the end of a List), the access will return \nnil\n.\n\n\nIt is also possible to directly assign an individual element of a collection using \naccess-assignment notation\n. This looks just like a collection access used as the target of an assignment. For example:\n\n\nlist\n \n=\n \n[\n1\n,\n \n2\n,\n \n3\n]\n\n\nlist\n[\n0\n]\n \n=\n \n4\n\n\nlist\n \n#=\n [4, 2, 3]\n\n\n\n\n\nNotice that this directly modifies the collection itself, but is not considered an assignment \nto\n the collection.\n\n\nLogical operations and truthiness\n\n\nMyst provides two native logical operations, \"or\" (\n||\n) and \"and\" (\n). These operate based on the truthiness of the first operand. The result of a logical operation is the value that determined the action taken by the operation - no conversions to Booleans or other operations are done to the value.\n\n\nAll values are considered truthy unless they are either \nnil\n or \nfalse\n. This means that, unlike some languages such as C or JavaScript, \n0\n, \n[]\n, \n{}\n, and \n are \nall\n considered truthy.\n\n\nLogical operations in Myst are also short-circuiting, meaning that the right side operand will only be evaluated if the left side operand does not satisfy the operation. For an Or operation, that is when the left side operand is falsey, or truthy for an And operation.\n\n\nBelow are some examples of logical operations and the results they would yield.\n\n\nfalse\n \n||\n \nfalse\n  \n#=\n false\n\n\nfalse\n \n||\n \ntrue\n   \n#=\n true\n\n\ntrue\n  \n||\n \nfalse\n  \n#=\n true\n\n\n1\n     \n||\n \n2\n      \n#=\n 1\n\n\nnil\n   \n||\n \n2\n      \n#=\n 2\n\n\n\nfalse\n \n \nfalse\n  \n#=\n false\n\n\nfalse\n \n \ntrue\n   \n#=\n false\n\n\ntrue\n  \n \nfalse\n  \n#=\n false\n\n\ntrue\n  \n \ntrue\n   \n#=\n true\n\n\nnil\n   \n \n2\n      \n#=\n nil\n\n\n[]\n    \n \ntrue\n   \n#=\n false\n\n\n\n\n\nIt's worth noting that since there are two falsey values, the result of a failed logical operation (one that is not satisfied) can be \neither\n \nnil\n or \nfalse\n, but no other value. For example:\n\n\n[]\n \n \nfalse\n   \n#=\n false\n\n\nfalse\n \n||\n \nnil\n  \n#=\n nil\n\n\n\n\n\nUnlike most other operators in Myst, \n||\n and \n are native to the language, and cannot be overridden. Operators that \nare\n overridable have a receiver (the left) and an argument (the right), but the logical operators are defined by the two operands equally. Because of that, it does not make sense for logical operations to be overridable.\n\n\nComparison operations\n\n\nMyst provides all of the common comparison operators: \n, \n=\n, \n==\n, \n!=\n, \n=\n, and \n. These operations should always return a boolean value, but can be changed by overridden behavior.\n\n\nAll types define \n==\n and \n!=\n. These are also the only comparison operations that booleans and nil define by default.\n\n\ntrue\n \n==\n \nfalse\n \n#=\n false\n\n\ntrue\n \n!=\n \nfalse\n \n#=\n true\n\n\nnil\n  \n==\n \nnil\n    \n#=\n true\n\n\nnil\n  \n==\n \nfalse\n  \n#=\n false\n\n\n\n\n\nAn important thing to note in the example above is that \nnil\n will only ever be equal to \nnil\n. The fact that \nnil\n and \nfalse\n are both falsey does not apply to equality operations.\n\n\nEquality operations are always based on values rather than object ids, as in Java and other similar languages. That means there should never be a concern about using \n.equals\n or \n.eql\n or other special methods instead of \n==\n for things like Strings.\n\n\nhello\n \n==\n \nhello\n \n#=\n true\n\n\n\n\n\nThe remainder of the comparison operators are implemented selectively for each type. For numeric types, the default implementations for all of these operators all perform their mathematic definition:\n\n\n1\n  \n  \n2\n       \n#=\n true\n\n\n10\n \n==\n \n20\n      \n#=\n false\n\n\n5\n  \n=\n \n5\n.\n4\n     \n#=\n false\n\n\n\n\n\nOperations between a Float and an Integer operand on either side will also work as expected.\n\n\n1\n.\n0\n \n==\n \n1\n      \n#=\n true\n\n\n1\n   \n==\n \n1\n.\n1\n    \n#=\n false\n\n\n\n\n\nCollection types also implement \n and \n=\n to check whether the left side is a subset of the right side. Specifically, \n is a \nproper subset\n check, meaning the right side must be a larger collection than the left side, while \n=\n also allows the collections to be equal. The order of elements in the collection is not important for either of these operations.\n\n\n[\n1\n,\n \n2\n]\n \n  \n[\n1\n,\n \n2\n]\n        \n#=\n false\n\n\n[\n2\n,\n \n1\n]\n \n=\n \n[\n1\n,\n \n2\n]\n        \n#=\n true\n\n\n{\nb\n:\n \n2\n}\n \n  \n{\na\n:\n \n1\n,\n \nb\n:\n \n2\n}\n  \n#=\n true\n\n\n\n\n\nUnary operations\n\n\nUnary operations are operations with a single operand (the receiver), and are always written as prefixes for the operand. The three unary operations supported by Myst are \n!\n, \n-\n, and \n*\n, any combination of which can be chained together.\n\n\n!\n performs a logical \"not\" on the operand. Truthy values become \nfalse\n, while falsey values become \ntrue\n. The result is always a Boolean. For example:\n\n\n!\ntrue\n   \n#=\n false\n\n\n!\nfalse\n  \n#=\n true\n\n\n!\nnil\n    \n#=\n true\n\n\n![]\n     \n#=\n false\n\n\n!!\n100\n   \n#=\n true\n\n\n\n\n\nThe last line above is an example of a \"double not\". This is a common pattern for quickly getting the truthiness of a value as a Boolean.\n\n\nThe unary version of \n-\n is a negation. For numeric types, this is essentially equivalent to the binary operation with \n0\n as the receiver (i.e., \n-2\n is the same as \n0 - 2\n).\n\n\na\n \n=\n \n100\n\n\n-\na\n        \n#=\n -100\n\n\n--\na\n       \n#=\n 100\n\n\n\n\n\nAgain, \n-\n can be chained to perform \"double negation\", though this is not immediately useful with any of the native types.\n\n\nFinally, \n*\n is known the \"splat\" operator. Usage of the splat operator goes far beyond unary operation usage, and will be further explained in later sections, but the general idea of the operation is to return a List representation of the operand.\n\n\nFor example, \nMap#*\n returns a List of 2-element Lists with keys as the first elements and values as the second elements. For example:\n\n\n*\n{\na\n:\n \n1\n,\n \nb\n:\n \n2\n}\n \n#=\n [[:a, 1], [:b, 2]]\n\n\n\n\n\nThe splat operator for a List (at least as a unary operation) will simply return the List itself.\n\n\n*[\n1\n,\n \n2\n,\n \n3\n]\n \n#=\n [1, 2, 3]\n\n\n\n\n\nThere generally are not many use cases for the splat operator as a unary operation. It is much more commonly used in the special cases described later on, namely in pattern matching and expanding arguments for functions.\n\n\nOperational assignment\n\n\nAs mentioned in the previous chapter, Myst provides a shorthand to perform an operation on a variable and assign it back into the same variable, known as \noperational assignment\n.\n\n\nOperational assignments take the form \nop=\n, where \nop\n is the operator to apply before re-assigning the variable. The semantic expansion of operational assignments goes from \na op= b\n to \na = a op b\n. Some examples:\n\n\na\n \n=\n \n1\n\n\na\n \n+=\n \n2\n  \n#=\n 3\n\n\na\n \n*=\n \n2\n  \n#=\n 6\n\n\na\n \n%= 3  #=\n \n0\n\n\n\n\n\nOperational assignment works for every \nbinary\n operation shown in this chapter. However, the logical operators (\n||\n and \n) have special behavior when written as operational assignments.\n\n\nOr-assignment\n\n\n||=\n, referred to as \"or-assignment\" loosely expands from \na ||= b\n to \na || a = b\n, rather than the normal \na = a || b\n. This is a \"loose\" expansion, because \na\n does not have to exist before the assignment is written.\n\n\nThe expression \na ||= b\n will always assign \nb\n into \na\n, so long as the \na\n is not a truthy value. If a does not yet exist, it is considered falsey by the assignment and created as a new variable with the value of \nb\n.\n\n\nIf the value of \na\n is truthy, the assignment will not occur, and the existing value for \na\n will be returned as the result.\n\n\na\n \n||=\n \n2\n  \n#=\n 2\n\n\n# `a` is truthy, so no assignment occurs.\n\n\na\n \n||=\n \n3\n  \n#=\n 3\n\n\n\nz\n \n||=\n \nnil\n   \n#=\n nil\n\n\n# `nil` is falsey, so assignment occurs.\n\n\nz\n \n||=\n \nfalse\n \n#=\n false\n\n\nz\n \n||=\n \n3\n     \n#=\n 3\n\n\nz\n \n||=\n \n4\n     \n#=\n 4\n\n\n\n\n\nA consequence of how \n||=\n works means that the target is guaranteed to exist after the assignment, making it useful for ensuring default values for variables that may not exist beforehand.\n\n\nAnd-assignment\n\n\n=\n (\"and-assignment\") acts exactly like \n||=\n, but with an \n operation instead. In this case, the left side must be truthy for the assignment to occur.\n\n\na\n \n=\n \nfalse\n\n\na\n \n=\n \n1\n     \n#=\n false\n\n\na\n \n=\n \n1\n\n\na\n \n=\n \n2\n     \n#=\n 2\n\n\n\nz\n \n=\n \n1\n     \n#=\n nil\n\n\nz\n \n=\n \n2\n     \n#=\n nil\n\n\n\n\n\nThe last two lines above may be a little surprising - one of the few cases of potentially unintuitive behavior in Myst. As mentioned above, \n=\n acts \nexactly\n like \n||=\n, and a consequence of \n||=\n is that the target will \nalways\n exist after the operation is completed.\n\n\nHowever, since the assumed value of a non-existent variable is falsey, the assignment in an \n=\n operation is not guaranteed to happen. Logically, this makes sense, but practically it can become annoying. For example, consider the code required if \n=\n did \nnot\n always initialize the target variable:\n\n\nz\n \n||=\n \nnil\n\n\nz\n \n=\n \n1\n\n\n\n\n\nHere, we're trying to say that if \nz\n does not exist, create it with a \nnil\n value, then do the and-assignment. But, as you may have picked up, this actually won't always work, because if \nz\n exists beforehand but is falsey, the or-assignment will occur, potentially changing the value of \nz\n (if it was \nfalse\n, it would become \nnil\n).\n\n\nTo avoid this extra line that is still not guaranteed to work, Myst defaults the target variable to \nnil\n, which will ensure that the assignment does not occur (since a non-existent value is considered falsey), but will also ensure that the target variable is assigned after the operation is completed (matching the semantics of \n||=\n).", 
            "title": "Basic Operations"
        }, 
        {
            "location": "/basic_operations/#basic-operations", 
            "text": "With the knowledge of values and how they are managed, let's look at some ways that they can be manipulated.  Almost all of the basic operators are actually defined as methods on the types of objects. For example, the expression  1 + 2  calls the + method on the value  1 , with  2  as an argument. This method-based approach means that these operators can be overridden on any type at any time.  The examples in this section will almost exclusively use literal values to clearly show the types involved in the operations, but all of the operators can be used with variables or sometimes even types or modules instead with the same effects.", 
            "title": "Basic Operations"
        }, 
        {
            "location": "/basic_operations/#mathematic-operations", 
            "text": "Most primitive values define the basic arithmetic operations:  + ,  - ,  * ,  / , and  % . Some examples:  1   +   1         #=  2  2 . 6   +   3 . 8     #=  6.4  10   *   10       #=  100  120   %   100     #=  20  h   +   i     #=   hi   Collections also implement some operations like  + :  [ 1 ,   2 ]   +   [ 3 ,   4 ]   #=  [1, 2, 3, 4]  { a :   1 }   +   { b :   2 }   #=  {a: 1, b: 2}   For Maps, keys are unique, so adding two Maps that contain the same key will give the key in the result the value of the second Map. For example:  { a :   1 ,   b :   2 }   +   { a :   2 ,   c :   3 }  #=  {a: 2, b: 2, c: 3}   This can be useful for quickly applying default values to a Map, but may also lead to some unexpected behavior if it is not understood beforehand.  Most value types define a number of other mathematic operations, such as  String#*  and  List#- . There are too many to cover comprehensively in this guide, so be sure to check the documentation for a more complete look at the operations that are available.", 
            "title": "Mathematic operations"
        }, 
        {
            "location": "/basic_operations/#collection-access", 
            "text": "To access individual values within a collection, Myst provides  access notation  via square braces ( [  and  ] ) with an index argument between them:  list   =   [ 1 ,   2 ,   3 ]  list [ 0 ]   #=  1  map   =   { a :   1 ,   b :   2 }  map [ :b ]   #=  2   Lists use zero-based indexing, meaning the first element of a List is at position  0 , and the last element of the List is at position  n-1 , where  n  is the number of elements in the List.  In a List, the index argument is generally only allowed to be an Integer. For Maps, the index can be any type, but will generally be a Symbol, following the preference that Map keys should use Symbols.  In any case, if the element at the given index does not exist (e.g., the key is not in the Map, of the index is past the end of a List), the access will return  nil .  It is also possible to directly assign an individual element of a collection using  access-assignment notation . This looks just like a collection access used as the target of an assignment. For example:  list   =   [ 1 ,   2 ,   3 ]  list [ 0 ]   =   4  list   #=  [4, 2, 3]   Notice that this directly modifies the collection itself, but is not considered an assignment  to  the collection.", 
            "title": "Collection access"
        }, 
        {
            "location": "/basic_operations/#logical-operations-and-truthiness", 
            "text": "Myst provides two native logical operations, \"or\" ( || ) and \"and\" ( ). These operate based on the truthiness of the first operand. The result of a logical operation is the value that determined the action taken by the operation - no conversions to Booleans or other operations are done to the value.  All values are considered truthy unless they are either  nil  or  false . This means that, unlike some languages such as C or JavaScript,  0 ,  [] ,  {} , and   are  all  considered truthy.  Logical operations in Myst are also short-circuiting, meaning that the right side operand will only be evaluated if the left side operand does not satisfy the operation. For an Or operation, that is when the left side operand is falsey, or truthy for an And operation.  Below are some examples of logical operations and the results they would yield.  false   ||   false    #=  false  false   ||   true     #=  true  true    ||   false    #=  true  1       ||   2        #=  1  nil     ||   2        #=  2  false     false    #=  false  false     true     #=  false  true      false    #=  false  true      true     #=  true  nil       2        #=  nil  []        true     #=  false   It's worth noting that since there are two falsey values, the result of a failed logical operation (one that is not satisfied) can be  either   nil  or  false , but no other value. For example:  []     false     #=  false  false   ||   nil    #=  nil   Unlike most other operators in Myst,  ||  and   are native to the language, and cannot be overridden. Operators that  are  overridable have a receiver (the left) and an argument (the right), but the logical operators are defined by the two operands equally. Because of that, it does not make sense for logical operations to be overridable.", 
            "title": "Logical operations and truthiness"
        }, 
        {
            "location": "/basic_operations/#comparison-operations", 
            "text": "Myst provides all of the common comparison operators:  ,  = ,  == ,  != ,  = , and  . These operations should always return a boolean value, but can be changed by overridden behavior.  All types define  ==  and  != . These are also the only comparison operations that booleans and nil define by default.  true   ==   false   #=  false  true   !=   false   #=  true  nil    ==   nil      #=  true  nil    ==   false    #=  false   An important thing to note in the example above is that  nil  will only ever be equal to  nil . The fact that  nil  and  false  are both falsey does not apply to equality operations.  Equality operations are always based on values rather than object ids, as in Java and other similar languages. That means there should never be a concern about using  .equals  or  .eql  or other special methods instead of  ==  for things like Strings.  hello   ==   hello   #=  true   The remainder of the comparison operators are implemented selectively for each type. For numeric types, the default implementations for all of these operators all perform their mathematic definition:  1       2         #=  true  10   ==   20        #=  false  5    =   5 . 4       #=  false   Operations between a Float and an Integer operand on either side will also work as expected.  1 . 0   ==   1        #=  true  1     ==   1 . 1      #=  false   Collection types also implement   and  =  to check whether the left side is a subset of the right side. Specifically,   is a  proper subset  check, meaning the right side must be a larger collection than the left side, while  =  also allows the collections to be equal. The order of elements in the collection is not important for either of these operations.  [ 1 ,   2 ]      [ 1 ,   2 ]          #=  false  [ 2 ,   1 ]   =   [ 1 ,   2 ]          #=  true  { b :   2 }      { a :   1 ,   b :   2 }    #=  true", 
            "title": "Comparison operations"
        }, 
        {
            "location": "/basic_operations/#unary-operations", 
            "text": "Unary operations are operations with a single operand (the receiver), and are always written as prefixes for the operand. The three unary operations supported by Myst are  ! ,  - , and  * , any combination of which can be chained together.  !  performs a logical \"not\" on the operand. Truthy values become  false , while falsey values become  true . The result is always a Boolean. For example:  ! true     #=  false  ! false    #=  true  ! nil      #=  true  ![]       #=  false  !! 100     #=  true   The last line above is an example of a \"double not\". This is a common pattern for quickly getting the truthiness of a value as a Boolean.  The unary version of  -  is a negation. For numeric types, this is essentially equivalent to the binary operation with  0  as the receiver (i.e.,  -2  is the same as  0 - 2 ).  a   =   100  - a          #=  -100  -- a         #=  100   Again,  -  can be chained to perform \"double negation\", though this is not immediately useful with any of the native types.  Finally,  *  is known the \"splat\" operator. Usage of the splat operator goes far beyond unary operation usage, and will be further explained in later sections, but the general idea of the operation is to return a List representation of the operand.  For example,  Map#*  returns a List of 2-element Lists with keys as the first elements and values as the second elements. For example:  * { a :   1 ,   b :   2 }   #=  [[:a, 1], [:b, 2]]   The splat operator for a List (at least as a unary operation) will simply return the List itself.  *[ 1 ,   2 ,   3 ]   #=  [1, 2, 3]   There generally are not many use cases for the splat operator as a unary operation. It is much more commonly used in the special cases described later on, namely in pattern matching and expanding arguments for functions.", 
            "title": "Unary operations"
        }, 
        {
            "location": "/basic_operations/#operational-assignment", 
            "text": "As mentioned in the previous chapter, Myst provides a shorthand to perform an operation on a variable and assign it back into the same variable, known as  operational assignment .  Operational assignments take the form  op= , where  op  is the operator to apply before re-assigning the variable. The semantic expansion of operational assignments goes from  a op= b  to  a = a op b . Some examples:  a   =   1  a   +=   2    #=  3  a   *=   2    #=  6  a   %= 3  #=   0   Operational assignment works for every  binary  operation shown in this chapter. However, the logical operators ( ||  and  ) have special behavior when written as operational assignments.", 
            "title": "Operational assignment"
        }, 
        {
            "location": "/basic_operations/#or-assignment", 
            "text": "||= , referred to as \"or-assignment\" loosely expands from  a ||= b  to  a || a = b , rather than the normal  a = a || b . This is a \"loose\" expansion, because  a  does not have to exist before the assignment is written.  The expression  a ||= b  will always assign  b  into  a , so long as the  a  is not a truthy value. If a does not yet exist, it is considered falsey by the assignment and created as a new variable with the value of  b .  If the value of  a  is truthy, the assignment will not occur, and the existing value for  a  will be returned as the result.  a   ||=   2    #=  2  # `a` is truthy, so no assignment occurs.  a   ||=   3    #=  3  z   ||=   nil     #=  nil  # `nil` is falsey, so assignment occurs.  z   ||=   false   #=  false  z   ||=   3       #=  3  z   ||=   4       #=  4   A consequence of how  ||=  works means that the target is guaranteed to exist after the assignment, making it useful for ensuring default values for variables that may not exist beforehand.", 
            "title": "Or-assignment"
        }, 
        {
            "location": "/basic_operations/#and-assignment", 
            "text": "=  (\"and-assignment\") acts exactly like  ||= , but with an   operation instead. In this case, the left side must be truthy for the assignment to occur.  a   =   false  a   =   1       #=  false  a   =   1  a   =   2       #=  2  z   =   1       #=  nil  z   =   2       #=  nil   The last two lines above may be a little surprising - one of the few cases of potentially unintuitive behavior in Myst. As mentioned above,  =  acts  exactly  like  ||= , and a consequence of  ||=  is that the target will  always  exist after the operation is completed.  However, since the assumed value of a non-existent variable is falsey, the assignment in an  =  operation is not guaranteed to happen. Logically, this makes sense, but practically it can become annoying. For example, consider the code required if  =  did  not  always initialize the target variable:  z   ||=   nil  z   =   1   Here, we're trying to say that if  z  does not exist, create it with a  nil  value, then do the and-assignment. But, as you may have picked up, this actually won't always work, because if  z  exists beforehand but is falsey, the or-assignment will occur, potentially changing the value of  z  (if it was  false , it would become  nil ).  To avoid this extra line that is still not guaranteed to work, Myst defaults the target variable to  nil , which will ensure that the assignment does not occur (since a non-existent value is considered falsey), but will also ensure that the target variable is assigned after the operation is completed (matching the semantics of  ||= ).", 
            "title": "And-assignment"
        }, 
        {
            "location": "/values_and_variables/", 
            "text": "Values And Variables\n\n\nMyst is a strong, dynamically typed language. At a high level, \"strong\" means that every value has a specified type, and will retain that type unless explicitly told to change, and \"dynamic\" means that variables can hold any type of value at any time.\n\n\nThe exact meanings of \"strong\" and \"dynamic\" aren't entirely universal - people have varying ideas on the minor details - and can get surprisingly complex depending on how exact the definition is.\n\n\nHowever, as with many other concepts, Myst implements a more pragmatic approach. Later on, we'll see that Myst provides a few different ways to restrict the types that variables can accept. For now though, \"strong\" and \"dynamic\" are sufficient descriptions of Myst's type system.\n\n\nValue Literals\n\n\nMyst has a number of literal representations for values. These are the most basic way of creating new values in a program. Some examples of literals include:\n\n\nnil\n           \n# Nil (`null` in some languages)\n\n\nfalse\n         \n# Boolean\n\n\ntrue\n          \n# Boolean\n\n\n1\n             \n# Integer\n\n\n1\n.\n0\n           \n# Float\n\n\nhello\n       \n# String\n\n\n:hello\n        \n# Symbol\n\n\n[\n1\n,\n \n2\n,\n \n3\n]\n     \n# List\n\n\n{\na\n:\n \n1\n,\n \nb\n:\n \n2\n}\n  \n# Map\n\n\n\n\n\nnil\n, \nfalse\n, and \ntrue\n are all \nconstant literals\n. That is, they always refer to the same object, and the same keyword is always used to refer to them. All other literals are mutable, in the sense that the exact representation can vary.\n\n\nNumerics\n\n\nNumerics are values that represent numbers. Myst supports Integers and Floats as numeric values.\n\n\nAn Integer is any whole number, such as \n2\n, \n100\n, or \n987654321\n. Integer literals in Myst can also contain underscores to help separate groups of digits. This is particularly useful for large numbers. For example, compare these two representations of 1 billion:\n\n\n11000000000\n\n\n21_000_000_000\n\n\n\n\n\nIn the version with underscores, it's clear to see that there are 3 groups of \n000\n's, allowing someone reading the code to quickly see that the value is 1 billion.\n\n\nFloats are real numbers that may contain decimal values, such as \n1.0\n, \n2.345\n, or \n123.456789\n. Notice that \n1.0\n is a whole number, and thus technically an integer, but the representation as \n1.0\n indicates to Myst that the value is a Float. This relates to the strong typing mentioned above, where operations like division may behave differently based on the type of the operands.\n\n\nAs with Integers, underscores are allowed in Float literals, both before and after the decimal point:\n\n\n123_456\n.\n789_0123\n\n\n\n\n\nThere is no restriction on how many underscores can be given in a literal, or that they have to form groups of 3. The following are all valid numeric literals, though they are generally avoided for consistency:\n\n\n11_\n2100_00\n3255_._255\n41_2_3_4\n59_____9\n\n\n\n\nStrings\n\n\nA String is any series of zero or more characters contained between two double quote (\n) characters. The following are all valid strings:\n\n\nmyst\n\n\n\n\nhello, world!\n\n\n1 + 2 == 3\n\n\n\n\n\nAll whitespace within a string is preserved, meaning Strings can span multiple lines:\n\n\nhello,\n\n\nworld\n\n\n\n\n\nAlternatively, this could be condensed using an escape sequence for the newline character:\n\n\nhello,\n\\n\nworld\n\n\n\n\n\nOther escape sequences include tab characters (\n\\t\n), null terminators (\n\\0\n), and a double quote within the string (\n\\\n). If a String needs to contain the \n\\\n character itself, it must also be escaped to avoid ambiguity:\n\n\nhi \\o\n  \n#=\n The `\\` will escape the `o`.\n\n\nhi \n\\\\\no\n \n#=\n The String will contain a `\\` character.\n\n\n\n\n\nSymbols\n\n\nSymbols are similar to Strings, but with a different representation within the language that we'll cover soon.\n\n\nA Symbol literal is a \nname\n or \nidentifier\n prefixed with a colon. The following would all be interpreted as Symbols in Myst:\n\n\n:hello\n\n\n:two_words\n\n\n:true\n\n\n:false\n\n\n:nil\n\n\n:__with_some_underscores___\n\n\n:numbers123\n\n\n\n\n\nAdditionally, Symbols can be created from a String literal the same way. This is useful for creating symbols with spaces in the name or with other special characters:\n\n\n:\n \n\n\n:\nhello, world\n\n\n:\n+\n\n\n:\n /afs% 1234\n\n\n\n\n\nNow, the way that Symbols are different than Strings is how they are stored within the language. Each Symbol is represented as an Integer. More importantly, every Symbol with the same name is represented by the \nsame\n Integer. So, a Symbol, \n:name\n, may be represented by the Integer \n153\n, then another Symbol, \n:name\n, would also be represented by \n153\n.\n\n\nThis makes comparisons with Symbols extremely efficient (just comparing two integers, rather than each character in the name), which makes them great for cases where the name of the Symbol isn't necessarily important, but performance matters (such as Maps, as seen below).\n\n\nCollections\n\n\nApart from the individual literal types, Myst also has literal representations of two collection types: Lists and Maps. These are very common in Myst code, so it's important that they be easily and clearly represented.\n\n\nA List is an ordered collection of values. Any combination of values can be added to a List. List literals are surrounded by square braces (\n[\n and \n]\n), with each entry separated by a comma (and optionally some whitespace). All of the following are valid List literals:\n\n\n[]\n\n\n[\n1\n]\n\n\n[\n1\n,\n \n2\n,\n \n3\n]\n\n\n[\nnil\n,\n \n1\n.\n0\n,\n \nhello\n]\n\n\n[\n\n  \n1\n,\n \n2\n,\n\n  \ntrue\n,\n \nfalse\n,\n\n  \nhi\n,\n \n:hello\n\n\n]\n\n\n\n\n\nLists can also be nested within each other to create more complex structures:\n\n\n[\n\n  \n[\ntrue\n,\n \n0\n]\n,\n\n  \n[\nfalse\n,\n \n1\n,\n \n2\n]\n,\n\n  \n[\n\n    \n[\nhi\n,\n \n[]]\n,\n\n    \n[\n:hello\n,\n \nnil\n]\n\n  \n]\n\n\n]\n\n\n\n\n\nWe'll see some more ways that Lists are useful in Myst later on.\n\n\nA Map, on the other hand, is a collection of key-value pairs. In Myst, the order of the entries is also preserved. By default, all Map keys will be Symbols, but the value can be of any type.\n\n\nA Map literal is created using curly braces (\n{\n and \n}\n), with comma-separated entries, similar to Lists. Each \nentry\n of a Map is written as a key name followed by a colon, followed by the value for that key. All of the following are valid Map literals:\n\n\n{}\n\n\n{\na\n:\n \n1\n}\n\n\n{\na\n:\n \n1\n,\n \nb\n:\n \n2\n}\n\n\n{\ntrue\n:\n \ntrue\n,\n \nfalse\n:\n \nfalse\n}\n\n\n{\n\n  \nnumber1\n:\n \n1234\n,\n\n  \n__thing\n:\n \n{\n\n    \nstring\n:\n \nhi\n,\n\n    \nsymbol\n:\n \n:hi\n\n  \n}\n\n\n}\n\n\n\n\n\nNotice that the Symbol keys do not \nstart\n with a colon, because the colon is instead placed \nafter\n the name.\n\n\nGenerally, Maps do \nnot\n put a space between the braces and the entries of the Map, but \ndoes\n include a space between each entry. This is to avoid ambiguities with other braced constructs that we'll see later on.\n\n\nIt's possible to use other types of values as keys for Maps, which we'll see later on, but the preference is to always use Symbols. Earlier, we saw how Symbols can be compared efficiently as Integers which makes their use as Map keys very effective. Using other types will generally slow down performance.\n\n\nA final note on collections: nesting is not limited to the same type. It's just as easy to create Lists of Maps or Maps of Lists. For example:\n\n\n[\n\n  \n{\na\n:\n \n1\n,\n \nb\n:\n \n2\n},\n\n  \n{\na\n:\n \n3\n,\n \nb\n:\n \n4\n}\n\n\n]\n\n\n\n\n\nVariables\n\n\nVariables are names that store values. For the most part, any value can be assigned to any variable at any time.\n\n\nAll variable names in Myst are \nidentifiers\n. An identifier is any series of letters, numbers, and/or underscores, with the restriction that the first character can not be a number. The casing and structure of the name determines it's \nkind\n.\n\n\nThere are three main kinds of variables in Myst - Locals, Underscores, and Constants - each with a specific purpose and use case.\n\n\nLocals\n\n\nLocal variables start with a lowercase alphabetic character and are generally written in \nsnake_case\n. Locals can be freely assigned and referenced any number of times, and are generally used to hold temporary data.\n\n\nFor example, when doing a complex calculation, intermediate results are generally held in local variables to make the final calculation more clear.\n\n\nLocal variables are tied to the \nlexical scope\n that they are created in. In other words, variables created within a block of code will be destroyed once the block of code is finished running.\n\n\nAll of the following are examples of valid local variable names:\n\n\nx\n\n\na\n\n\nsomething_longer\n\n\nnumber1\n\n\nnum_456\n\n\n\n\n\nUnderscores\n\n\nUnderscores are local variables that start with an ASCII underscore character, \n_\n.\n\n\nJust like locals, underscore variables can be assigned to and referenced any number of times. However, referencing an underscore variable will emit a warning.\n\n\nGenerally, underscores are used to indicate that a variable is known to exist, but should not be used in the code. We'll see examples of how this is helpful later on, namely with function parameters and pattern matching.\n\n\nIn some languages, there is a pattern of using a single underscore character to indicate that a value is unwanted. Some languages even treat the single underscore specially.\n\n\nOther languages, Myst included, treat all underscore variables equally. As such, it's often useful to provide a more descriptive name for the underscore variable in case it may become useful in the future.\n\n\nFor example, this code is entirely valid:\n\n\n[\nfirst_name\n,\n \n_\n,\n \n_\n,\n \n_\n]\n \n=\n \nsome_method\n\n\n\n\n\nWe'll cover exactly what this means later on, but it's obvious that there are three values we don't \ncurrently\n care about. The issue is that without looking at the definition of \nsome_method\n, it's hard to tell \nwhat\n those values are, and if they could be useful in the code that follows it.\n\n\nA better version of the above would be something like this:\n\n\n[\nfirst\n,\n \n_last\n,\n \n_age\n,\n \n_city\n]\n \n=\n \nsome_method\n\n\n\n\n\nHere, we can see what the other three values are, but they are still marked as undercsore variables, meaning we don't currently have a use for them.\n\n\nConstants\n\n\nConstants start with uppercase alphabetic characters, and are written either in \nUpperCamelCase\n, or \nSCREAMING_CASE\n. Constants also have different semantics than underscores and local variables.\n\n\nA constant variable can only be assigned once. Assigning to a constant more than once will raise an error. As such, constants are generally used to hold values that are not expected to change very often. For example, the seasons of a year:\n\n\nSEASONS\n \n=\n \n[\nspring\n,\n \nsummer\n,\n \nfall\n,\n \nwinter\n]\n\n\n\n\n\nNote that while the constant \nitself\n cannot be reassigned, its value may still be changed by other operations. For example, a new season could be added just by adding to the end of the list.\n\n\nSEASONS\n[\n4\n]\n \n=\n \nsome new season\n\n\n\n\n\nWe'll cover more about what this code means later on, but the important part here is that constants can still be modified, even though they can only be assigned once.\n\n\nThe other primary use of constants is to represent types and modules. Earlier in this section, you may have noticed that we always refer to the type of a value with a capital letter at the start. This is to match the name of the type within Myst. Types like \nInteger\n, \nFloat\n, and \nList\n are all constants within Myst.\n\n\nTypes and modules will be covered in more detail later on, but know for now that a variable written in \nUpperCamelCase\n is generally referring to either a type or a module.\n\n\nAssignments\n\n\nAssignments are the primary way of creating new variables. All assignments consist of a \ntarget\n (the left side), an assignment operator, and a \nvalue\n (the right side).\n\n\nSimple assignments\n\n\nMost assignments are technically \nsimple assignments\n. Myst also has two other kinds of assignments (\"match\" and \"operational\") with different semantics.\n\n\nA simple assignment is made with a variable name (called the \ntarget\n) followed by an equals sign (\n=\n) and then some value to be assigned. We've seen this a few times already, but here's a more complete example:\n\n\nx\n \n=\n \n1\n \n#=\n 1\n\n\nx\n     \n#=\n 1\n\n\nx\n \n=\n \n2\n \n#=\n 2\n\n\nx\n     \n#=\n 2\n\n\n\n\n\nThe comment on each line shows what the value of x is after the line has finished running.\n\n\nOperational assignments\n\n\nIt's fairly common for an assignment to include the target in the value being assigned. For example, incrementing a variable by one might look somtehing like this:\n\n\nx\n \n=\n \nx\n \n+\n \n1\n\n\n\n\n\nEspecially with longer variable names, the repetition of the name creates unnecessary noise and often makes the assignment harder to understand at a glance.\n\n\nTo improve this, Myst provides \noperational assignments\n, which include the operation being performed as part of the assignment operator. The above example could be written as an operational assignment like this:\n\n\nx\n \n+=\n \n1\n\n\n\n\n\nThe full semantics of operational assignments will be covered in the Basic Operations section.\n\n\nMatch assignments\n\n\nMatch assignments use the match operator (\n=:\n). Match assignments are unique in that an assignment will not necessarily occur. Instead, the \"assignment\" is an expectation about the \nvalue\n of the assignment, rather than the \ntarget\n.\n\n\nThe full semantics of match assignments will be covered later on in the Pattern Matching section.\n\n\nInterpolations\n\n\nOne of the truly unique features of Myst as a language is the ability to interpolate (or \ninject\n) any value into another other section of code. An interpolation is creating using angle braces (\n and \n) with some expression between them.\n\n\nIn the Maps section, we saw that Map keys are almost always Symbols, but that it's possible to use other values for keys as well. One way to do this is to use interpolations:\n\n\n{\n\n  \ntrue\n:\n       \n:true\n,\n\n  \nhello\n:\n    \n:string\n,\n\n  \n[\n1\n,\n \n2\n,\n \n3\n]\n:\n  \n:list\n\n\n}\n\n\n\n\n\nWith this syntax, it's possible to use \nany\n value as the key for a Map entry, even Lists or other Maps. But, as mentioned before, using keys other than Symbols will hinder performance.\n\n\nInterpolations also allow operations within the interpolation for even more powerful behavior. For example, variables can be referenced within an interpolation,and calls to other functions can be made:\n\n\nx\n \n=\n \n1\n\n\nlist\n \n=\n \n[\n1\n,\n \n2\n,\n \n3\n]\n\n\n{\n\n  \nx\n:\n \n:one\n,\n\n  \nlist\n[\n2\n]\n \n:three\n\n\n}\n\n\n\n\n\nIn fact, \nany\n expression can be used inside of an interpolation, but will require additional parentheses to avoid ambiguity with the less-than and greater-than operations:\n\n\nx\n \n=\n \n15\n\n\n{\n\n  \n(\n1\n \n+\n \n2\n)\n:\n \n:three\n,\n\n  \n(\nx\n \n/\n \n3\n)\n:\n \n:five\n\n\n}\n\n\n\n\n\nAll of the examples so far have shown interpolations used for creating keys in a Map. While interpolations are allowed anywhere in Myst code, they generally don't have any additional effects that make them useful. For example, these two lines are equivalent:\n\n\nx\n \n=\n \n(\n1\n \n+\n \n2\n)\n\n\nx\n \n=\n \n1\n \n+\n \n2\n\n\n\n\n\nAnother common use for interpolations is inside of Strings. In addition to evaluating an expression in-place, String interpolations will also convert the result into a String representation before inserting it into the String:\n\n\nname\n \n=\n \nJohn Smith\n\n\nhello, \n(name)\n!\n \n#=\n \nhello, John Smith!\n\n\n\n\n\nNote that string interpolations \nalways\n require the additional parentheses around the expression being interpolated.\n\n\nString interpolations are expanded by the language into separate components for the literal String parts and the expressions, then summed together to create the result. The exact expansion would look like this:\n\n\n# Given a string like this:\n\n\n1 + 2 = \n(1 + 2)\n!\n\n\n# The language would interpret it as:\n\n\n1 + 2 = \n \n+\n \n(\n1\n \n+\n \n2\n)\n.\nto_s\n \n+\n \n!\n\n\n\n\n\nThis expansion is \nsemantically\n the same as what the language ends up doing, but would perform slower than the interpolated version since the language can make some optimizations when the values are interpolated.\n\n\nThe last main use case of interpolations is in pattern matching, which we'll see later on in the Pattern Matching section.", 
            "title": "Values And Variables"
        }, 
        {
            "location": "/values_and_variables/#values-and-variables", 
            "text": "Myst is a strong, dynamically typed language. At a high level, \"strong\" means that every value has a specified type, and will retain that type unless explicitly told to change, and \"dynamic\" means that variables can hold any type of value at any time.  The exact meanings of \"strong\" and \"dynamic\" aren't entirely universal - people have varying ideas on the minor details - and can get surprisingly complex depending on how exact the definition is.  However, as with many other concepts, Myst implements a more pragmatic approach. Later on, we'll see that Myst provides a few different ways to restrict the types that variables can accept. For now though, \"strong\" and \"dynamic\" are sufficient descriptions of Myst's type system.", 
            "title": "Values And Variables"
        }, 
        {
            "location": "/values_and_variables/#value-literals", 
            "text": "Myst has a number of literal representations for values. These are the most basic way of creating new values in a program. Some examples of literals include:  nil             # Nil (`null` in some languages)  false           # Boolean  true            # Boolean  1               # Integer  1 . 0             # Float  hello         # String  :hello          # Symbol  [ 1 ,   2 ,   3 ]       # List  { a :   1 ,   b :   2 }    # Map   nil ,  false , and  true  are all  constant literals . That is, they always refer to the same object, and the same keyword is always used to refer to them. All other literals are mutable, in the sense that the exact representation can vary.", 
            "title": "Value Literals"
        }, 
        {
            "location": "/values_and_variables/#numerics", 
            "text": "Numerics are values that represent numbers. Myst supports Integers and Floats as numeric values.  An Integer is any whole number, such as  2 ,  100 , or  987654321 . Integer literals in Myst can also contain underscores to help separate groups of digits. This is particularly useful for large numbers. For example, compare these two representations of 1 billion:  11000000000  21_000_000_000   In the version with underscores, it's clear to see that there are 3 groups of  000 's, allowing someone reading the code to quickly see that the value is 1 billion.  Floats are real numbers that may contain decimal values, such as  1.0 ,  2.345 , or  123.456789 . Notice that  1.0  is a whole number, and thus technically an integer, but the representation as  1.0  indicates to Myst that the value is a Float. This relates to the strong typing mentioned above, where operations like division may behave differently based on the type of the operands.  As with Integers, underscores are allowed in Float literals, both before and after the decimal point:  123_456 . 789_0123   There is no restriction on how many underscores can be given in a literal, or that they have to form groups of 3. The following are all valid numeric literals, though they are generally avoided for consistency:  11_\n2100_00\n3255_._255\n41_2_3_4\n59_____9", 
            "title": "Numerics"
        }, 
        {
            "location": "/values_and_variables/#strings", 
            "text": "A String is any series of zero or more characters contained between two double quote ( ) characters. The following are all valid strings:  myst   hello, world!  1 + 2 == 3   All whitespace within a string is preserved, meaning Strings can span multiple lines:  hello,  world   Alternatively, this could be condensed using an escape sequence for the newline character:  hello, \\n world   Other escape sequences include tab characters ( \\t ), null terminators ( \\0 ), and a double quote within the string ( \\ ). If a String needs to contain the  \\  character itself, it must also be escaped to avoid ambiguity:  hi \\o    #=  The `\\` will escape the `o`.  hi  \\\\ o   #=  The String will contain a `\\` character.", 
            "title": "Strings"
        }, 
        {
            "location": "/values_and_variables/#symbols", 
            "text": "Symbols are similar to Strings, but with a different representation within the language that we'll cover soon.  A Symbol literal is a  name  or  identifier  prefixed with a colon. The following would all be interpreted as Symbols in Myst:  :hello  :two_words  :true  :false  :nil  :__with_some_underscores___  :numbers123   Additionally, Symbols can be created from a String literal the same way. This is useful for creating symbols with spaces in the name or with other special characters:  :    : hello, world  : +  :  /afs% 1234   Now, the way that Symbols are different than Strings is how they are stored within the language. Each Symbol is represented as an Integer. More importantly, every Symbol with the same name is represented by the  same  Integer. So, a Symbol,  :name , may be represented by the Integer  153 , then another Symbol,  :name , would also be represented by  153 .  This makes comparisons with Symbols extremely efficient (just comparing two integers, rather than each character in the name), which makes them great for cases where the name of the Symbol isn't necessarily important, but performance matters (such as Maps, as seen below).", 
            "title": "Symbols"
        }, 
        {
            "location": "/values_and_variables/#collections", 
            "text": "Apart from the individual literal types, Myst also has literal representations of two collection types: Lists and Maps. These are very common in Myst code, so it's important that they be easily and clearly represented.  A List is an ordered collection of values. Any combination of values can be added to a List. List literals are surrounded by square braces ( [  and  ] ), with each entry separated by a comma (and optionally some whitespace). All of the following are valid List literals:  []  [ 1 ]  [ 1 ,   2 ,   3 ]  [ nil ,   1 . 0 ,   hello ]  [ \n   1 ,   2 , \n   true ,   false , \n   hi ,   :hello  ]   Lists can also be nested within each other to create more complex structures:  [ \n   [ true ,   0 ] , \n   [ false ,   1 ,   2 ] , \n   [ \n     [ hi ,   []] , \n     [ :hello ,   nil ] \n   ]  ]   We'll see some more ways that Lists are useful in Myst later on.  A Map, on the other hand, is a collection of key-value pairs. In Myst, the order of the entries is also preserved. By default, all Map keys will be Symbols, but the value can be of any type.  A Map literal is created using curly braces ( {  and  } ), with comma-separated entries, similar to Lists. Each  entry  of a Map is written as a key name followed by a colon, followed by the value for that key. All of the following are valid Map literals:  {}  { a :   1 }  { a :   1 ,   b :   2 }  { true :   true ,   false :   false }  { \n   number1 :   1234 , \n   __thing :   { \n     string :   hi , \n     symbol :   :hi \n   }  }   Notice that the Symbol keys do not  start  with a colon, because the colon is instead placed  after  the name.  Generally, Maps do  not  put a space between the braces and the entries of the Map, but  does  include a space between each entry. This is to avoid ambiguities with other braced constructs that we'll see later on.  It's possible to use other types of values as keys for Maps, which we'll see later on, but the preference is to always use Symbols. Earlier, we saw how Symbols can be compared efficiently as Integers which makes their use as Map keys very effective. Using other types will generally slow down performance.  A final note on collections: nesting is not limited to the same type. It's just as easy to create Lists of Maps or Maps of Lists. For example:  [ \n   { a :   1 ,   b :   2 }, \n   { a :   3 ,   b :   4 }  ]", 
            "title": "Collections"
        }, 
        {
            "location": "/values_and_variables/#variables", 
            "text": "Variables are names that store values. For the most part, any value can be assigned to any variable at any time.  All variable names in Myst are  identifiers . An identifier is any series of letters, numbers, and/or underscores, with the restriction that the first character can not be a number. The casing and structure of the name determines it's  kind .  There are three main kinds of variables in Myst - Locals, Underscores, and Constants - each with a specific purpose and use case.", 
            "title": "Variables"
        }, 
        {
            "location": "/values_and_variables/#locals", 
            "text": "Local variables start with a lowercase alphabetic character and are generally written in  snake_case . Locals can be freely assigned and referenced any number of times, and are generally used to hold temporary data.  For example, when doing a complex calculation, intermediate results are generally held in local variables to make the final calculation more clear.  Local variables are tied to the  lexical scope  that they are created in. In other words, variables created within a block of code will be destroyed once the block of code is finished running.  All of the following are examples of valid local variable names:  x  a  something_longer  number1  num_456", 
            "title": "Locals"
        }, 
        {
            "location": "/values_and_variables/#underscores", 
            "text": "Underscores are local variables that start with an ASCII underscore character,  _ .  Just like locals, underscore variables can be assigned to and referenced any number of times. However, referencing an underscore variable will emit a warning.  Generally, underscores are used to indicate that a variable is known to exist, but should not be used in the code. We'll see examples of how this is helpful later on, namely with function parameters and pattern matching.  In some languages, there is a pattern of using a single underscore character to indicate that a value is unwanted. Some languages even treat the single underscore specially.  Other languages, Myst included, treat all underscore variables equally. As such, it's often useful to provide a more descriptive name for the underscore variable in case it may become useful in the future.  For example, this code is entirely valid:  [ first_name ,   _ ,   _ ,   _ ]   =   some_method   We'll cover exactly what this means later on, but it's obvious that there are three values we don't  currently  care about. The issue is that without looking at the definition of  some_method , it's hard to tell  what  those values are, and if they could be useful in the code that follows it.  A better version of the above would be something like this:  [ first ,   _last ,   _age ,   _city ]   =   some_method   Here, we can see what the other three values are, but they are still marked as undercsore variables, meaning we don't currently have a use for them.", 
            "title": "Underscores"
        }, 
        {
            "location": "/values_and_variables/#constants", 
            "text": "Constants start with uppercase alphabetic characters, and are written either in  UpperCamelCase , or  SCREAMING_CASE . Constants also have different semantics than underscores and local variables.  A constant variable can only be assigned once. Assigning to a constant more than once will raise an error. As such, constants are generally used to hold values that are not expected to change very often. For example, the seasons of a year:  SEASONS   =   [ spring ,   summer ,   fall ,   winter ]   Note that while the constant  itself  cannot be reassigned, its value may still be changed by other operations. For example, a new season could be added just by adding to the end of the list.  SEASONS [ 4 ]   =   some new season   We'll cover more about what this code means later on, but the important part here is that constants can still be modified, even though they can only be assigned once.  The other primary use of constants is to represent types and modules. Earlier in this section, you may have noticed that we always refer to the type of a value with a capital letter at the start. This is to match the name of the type within Myst. Types like  Integer ,  Float , and  List  are all constants within Myst.  Types and modules will be covered in more detail later on, but know for now that a variable written in  UpperCamelCase  is generally referring to either a type or a module.", 
            "title": "Constants"
        }, 
        {
            "location": "/values_and_variables/#assignments", 
            "text": "Assignments are the primary way of creating new variables. All assignments consist of a  target  (the left side), an assignment operator, and a  value  (the right side).", 
            "title": "Assignments"
        }, 
        {
            "location": "/values_and_variables/#simple-assignments", 
            "text": "Most assignments are technically  simple assignments . Myst also has two other kinds of assignments (\"match\" and \"operational\") with different semantics.  A simple assignment is made with a variable name (called the  target ) followed by an equals sign ( = ) and then some value to be assigned. We've seen this a few times already, but here's a more complete example:  x   =   1   #=  1  x       #=  1  x   =   2   #=  2  x       #=  2   The comment on each line shows what the value of x is after the line has finished running.", 
            "title": "Simple assignments"
        }, 
        {
            "location": "/values_and_variables/#operational-assignments", 
            "text": "It's fairly common for an assignment to include the target in the value being assigned. For example, incrementing a variable by one might look somtehing like this:  x   =   x   +   1   Especially with longer variable names, the repetition of the name creates unnecessary noise and often makes the assignment harder to understand at a glance.  To improve this, Myst provides  operational assignments , which include the operation being performed as part of the assignment operator. The above example could be written as an operational assignment like this:  x   +=   1   The full semantics of operational assignments will be covered in the Basic Operations section.", 
            "title": "Operational assignments"
        }, 
        {
            "location": "/values_and_variables/#match-assignments", 
            "text": "Match assignments use the match operator ( =: ). Match assignments are unique in that an assignment will not necessarily occur. Instead, the \"assignment\" is an expectation about the  value  of the assignment, rather than the  target .  The full semantics of match assignments will be covered later on in the Pattern Matching section.", 
            "title": "Match assignments"
        }, 
        {
            "location": "/values_and_variables/#interpolations", 
            "text": "One of the truly unique features of Myst as a language is the ability to interpolate (or  inject ) any value into another other section of code. An interpolation is creating using angle braces (  and  ) with some expression between them.  In the Maps section, we saw that Map keys are almost always Symbols, but that it's possible to use other values for keys as well. One way to do this is to use interpolations:  { \n   true :         :true , \n   hello :      :string , \n   [ 1 ,   2 ,   3 ] :    :list  }   With this syntax, it's possible to use  any  value as the key for a Map entry, even Lists or other Maps. But, as mentioned before, using keys other than Symbols will hinder performance.  Interpolations also allow operations within the interpolation for even more powerful behavior. For example, variables can be referenced within an interpolation,and calls to other functions can be made:  x   =   1  list   =   [ 1 ,   2 ,   3 ]  { \n   x :   :one , \n   list [ 2 ]   :three  }   In fact,  any  expression can be used inside of an interpolation, but will require additional parentheses to avoid ambiguity with the less-than and greater-than operations:  x   =   15  { \n   ( 1   +   2 ) :   :three , \n   ( x   /   3 ) :   :five  }   All of the examples so far have shown interpolations used for creating keys in a Map. While interpolations are allowed anywhere in Myst code, they generally don't have any additional effects that make them useful. For example, these two lines are equivalent:  x   =   ( 1   +   2 )  x   =   1   +   2   Another common use for interpolations is inside of Strings. In addition to evaluating an expression in-place, String interpolations will also convert the result into a String representation before inserting it into the String:  name   =   John Smith  hello,  (name) !   #=   hello, John Smith!   Note that string interpolations  always  require the additional parentheses around the expression being interpolated.  String interpolations are expanded by the language into separate components for the literal String parts and the expressions, then summed together to create the result. The exact expansion would look like this:  # Given a string like this:  1 + 2 =  (1 + 2) !  # The language would interpret it as:  1 + 2 =    +   ( 1   +   2 ) . to_s   +   !   This expansion is  semantically  the same as what the language ends up doing, but would perform slower than the interpolated version since the language can make some optimizations when the values are interpolated.  The last main use case of interpolations is in pattern matching, which we'll see later on in the Pattern Matching section.", 
            "title": "Interpolations"
        }
    ]
}