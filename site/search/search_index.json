{
    "docs": [
        {
            "location": "/", 
            "text": "Myst\n\n\nA language for clarity from the start, flexibility when you need it, and efficiency where it matters.\n\n\ndeftype\n \nList\n\n  \ndef\n \ncontains\n(\nelement\n)\n\n    \neach\n(\nfn\n\n      \n-\n(\nelement\n)\n \n{\n \nbreak\n \ntrue\n \n}\n\n      \n-\n(\n_\n)\n         \n{\n \nfalse\n \n}\n\n    \nend\n)\n\n  \nend\n\n\nend\n\n\n\n[\n1\n,\n \n2\n,\n \n3\n].\ncontains\n(\n2\n)\n \n#=\n true\n\n\n\n\n\n\n\nNotice\n\n\nMyst is still very early on in its development. While the syntax stabilizing, there's still plenty of room for improvement, and even more openness to new ideas.\n\n\nIf you'd like to help shape the language, be an early adopter, or just follow along as things develop, it'd be great to see you in \nour discord server\n or \non GitHub.\n\n\n\n\nIntro\n\n\nMyst is a new programming language with the goal of bridging flexibility and practicality. By directly addressing common traps in modern dynamic programming, Myst provides users the ability to work quickly and easily with the power to write controlled, highly-structured code.\n\n\nWith heavy influences from Ruby, Elixir, Crystal, and other modern languages, Myst combines proven concepts like pattern matching and modular composition with some novel ideas, including global interpolation and fully optional typing. The result is a language that caters to natural thought and logic.\n\n\nSome of the high-level features of Myst include:\n\n\n\n\nPattern-matching everywhere.\n Assignments, method parameters, rescue * clauses, etc.\n\n\nMulti-clause functions.\n All functions can define multiple clauses to adapt functionality based on inputs.\n\n\nValue interpolations.\n Interpolate any value anywhere (even in * method parameters) with the \n syntax.\n\n\nSoft typing.\n Optional type annotations help control functionality without the clutter of conditionals.\n\n\nRaise anything.\n Any value can be raised as an exception and pattern matched by a rescue clause.", 
            "title": "Myst"
        }, 
        {
            "location": "/#myst", 
            "text": "A language for clarity from the start, flexibility when you need it, and efficiency where it matters.  deftype   List \n   def   contains ( element ) \n     each ( fn \n       - ( element )   {   break   true   } \n       - ( _ )           {   false   } \n     end ) \n   end  end  [ 1 ,   2 ,   3 ]. contains ( 2 )   #=  true    Notice  Myst is still very early on in its development. While the syntax stabilizing, there's still plenty of room for improvement, and even more openness to new ideas.  If you'd like to help shape the language, be an early adopter, or just follow along as things develop, it'd be great to see you in  our discord server  or  on GitHub.", 
            "title": "Myst"
        }, 
        {
            "location": "/#intro", 
            "text": "Myst is a new programming language with the goal of bridging flexibility and practicality. By directly addressing common traps in modern dynamic programming, Myst provides users the ability to work quickly and easily with the power to write controlled, highly-structured code.  With heavy influences from Ruby, Elixir, Crystal, and other modern languages, Myst combines proven concepts like pattern matching and modular composition with some novel ideas, including global interpolation and fully optional typing. The result is a language that caters to natural thought and logic.  Some of the high-level features of Myst include:   Pattern-matching everywhere.  Assignments, method parameters, rescue * clauses, etc.  Multi-clause functions.  All functions can define multiple clauses to adapt functionality based on inputs.  Value interpolations.  Interpolate any value anywhere (even in * method parameters) with the   syntax.  Soft typing.  Optional type annotations help control functionality without the clutter of conditionals.  Raise anything.  Any value can be raised as an exception and pattern matched by a rescue clause.", 
            "title": "Intro"
        }, 
        {
            "location": "/values_and_variables/", 
            "text": "Values And Variables\n\n\nMyst is a strong, dynamically typed language. At a high level, \"strong\" means that every value has a specified type, and will retain that type unless explicitly told to change, and \"dynamic\" means that variables can hold any type of value at any time.\n\n\nThe exact meanings of \"strong\" and \"dynamic\" aren't entirely universal - people have varying ideas on the minor details - and can get surprisingly complex depending on how exact the definition is.\n\n\nHowever, as with many other concepts, Myst implements a more pragmatic approach. Later on, we'll see that Myst provides a few different ways to restrict the types that variables can accept. For now though, \"strong\" and \"dynamic\" are sufficient descriptions of Myst's type system.\n\n\nValue Literals\n\n\nMyst has a number of literal representations for values. These are the most basic way of creating new values in a program. Some examples of literals include:\n\n\nnil\n           \n# Nil (`null` in some languages)\n\n\nfalse\n         \n# Boolean\n\n\ntrue\n          \n# Boolean\n\n\n1\n             \n# Integer\n\n\n1\n.\n0\n           \n# Float\n\n\nhello\n       \n# String\n\n\n:hello\n        \n# Symbol\n\n\n[\n1\n,\n \n2\n,\n \n3\n]\n     \n# List\n\n\n{\na\n:\n \n1\n,\n \nb\n:\n \n2\n}\n  \n# Map\n\n\n\n\n\nnil\n, \nfalse\n, and \ntrue\n are all \nconstant literals\n. That is, they always refer to the same object, and the same keyword is always used to refer to them. All other literals are mutable, in the sense that the exact representation can vary.\n\n\nNumerics\n\n\nNumerics are values that represent numbers. Myst supports Integers and Floats as numeric values.\n\n\nAn Integer is any whole number, such as \n2\n, \n100\n, or \n987654321\n. Integer literals in Myst can also contain underscores to help separate groups of digits. This is particularly useful for large numbers. For example, compare these two representations of 1 billion:\n\n\n11000000000\n\n\n21_000_000_000\n\n\n\n\n\nIn the version with underscores, it's clear to see that there are 3 groups of \n000\n's, allowing someone reading the code to quickly see that the value is 1 billion.\n\n\nFloats are real numbers that may contain decimal values, such as \n1.0\n, \n2.345\n, or \n123.456789\n. Notice that \n1.0\n is a whole number, and thus technically an integer, but the representation as \n1.0\n indicates to Myst that the value is a Float. This relates to the strong typing mentioned above, where operations like division may behave differently based on the type of the operands.\n\n\nAs with Integers, underscores are allowed in Float literals, both before and after the decimal point:\n\n\n123_456\n.\n789_0123\n\n\n\n\n\nThere is no restriction on how many underscores can be given in a literal, or that they have to form groups of 3. The following are all valid numeric literals, though they are generally avoided for consistency:\n\n\n11_\n2100_00\n3255_._255\n41_2_3_4\n59_____9\n\n\n\n\nStrings\n\n\nA String is any series of zero or more characters contained between two double quote (\n) characters. The following are all valid strings:\n\n\nmyst\n\n\n\n\nhello, world!\n\n\n1 + 2 == 3\n\n\n\n\n\nAll whitespace within a string is preserved, meaning Strings can span multiple lines:\n\n\nhello,\n\n\nworld\n\n\n\n\n\nAlternatively, this could be condensed using an escape sequence for the newline character:\n\n\nhello,\n\\n\nworld\n\n\n\n\n\nOther escape sequences include tab characters (\n\\t\n), null terminators (\n\\0\n), and a double quote within the string (\n\\\n). If a String needs to contain the \n\\\n character itself, it must also be escaped to avoid ambiguity:\n\n\nhi \\o\n  \n#=\n The `\\` will escape the `o`.\n\n\nhi \n\\\\\no\n \n#=\n The String will contain a `\\` character.\n\n\n\n\n\nSymbols\n\n\nSymbols are similar to Strings, but with a different representation within the language that we'll cover soon.\n\n\nA Symbol literal is a \nname\n or \nidentifier\n prefixed with a colon. The following would all be interpreted as Symbols in Myst:\n\n\n:hello\n\n\n:two_words\n\n\n:true\n\n\n:false\n\n\n:nil\n\n\n:__with_some_underscores___\n\n\n:numbers123\n\n\n\n\n\nAdditionally, Symbols can be created from a String literal the same way. This is useful for creating symbols with spaces in the name or with other special characters:\n\n\n:\n \n\n\n:\nhello, world\n\n\n:\n+\n\n\n:\n /afs% 1234\n\n\n\n\n\nNow, the way that Symbols are different than Strings is how they are stored within the language. Each Symbol is represented as an Integer. More importantly, every Symbol with the same name is represented by the \nsame\n Integer. So, a Symbol, \n:name\n, may be represented by the Integer \n153\n, then another Symbol, \n:name\n, would also be represented by \n153\n.\n\n\nThis makes comparisons with Symbols extremely efficient (just comparing two integers, rather than each character in the name), which makes them great for cases where the name of the Symbol isn't necessarily important, but performance matters (such as Maps, as seen below).\n\n\nCollections\n\n\nApart from the individual literal types, Myst also has literal representations of two collection types: Lists and Maps. These are very common in Myst code, so it's important that they be easily and clearly represented.\n\n\nA List is an ordered collection of values. Any combination of values can be added to a List. List literals are surrounded by square braces (\n[\n and \n]\n), with each entry separated by a comma (and optionally some whitespace). All of the following are valid List literals:\n\n\n[]\n\n\n[\n1\n]\n\n\n[\n1\n,\n \n2\n,\n \n3\n]\n\n\n[\nnil\n,\n \n1\n.\n0\n,\n \nhello\n]\n\n\n[\n\n  \n1\n,\n \n2\n,\n\n  \ntrue\n,\n \nfalse\n,\n\n  \nhi\n,\n \n:hello\n\n\n]\n\n\n\n\n\nLists can also be nested within each other to create more complex structures:\n\n\n[\n\n  \n[\ntrue\n,\n \n0\n]\n,\n\n  \n[\nfalse\n,\n \n1\n,\n \n2\n]\n,\n\n  \n[\n\n    \n[\nhi\n,\n \n[]]\n,\n\n    \n[\n:hello\n,\n \nnil\n]\n\n  \n]\n\n\n]\n\n\n\n\n\nWe'll see some more ways that Lists are useful in Myst later on.\n\n\nA Map, on the other hand, is a collection of key-value pairs. In Myst, the order of the entries is also preserved. By default, all Map keys will be Symbols, but the value can be of any type.\n\n\nA Map literal is created using curly braces (\n{\n and \n}\n), with comma-separated entries, similar to Lists. Each \nentry\n of a Map is written as a key name followed by a colon, followed by the value for that key. All of the following are valid Map literals:\n\n\n{}\n\n\n{\na\n:\n \n1\n}\n\n\n{\na\n:\n \n1\n,\n \nb\n:\n \n2\n}\n\n\n{\ntrue\n:\n \ntrue\n,\n \nfalse\n:\n \nfalse\n}\n\n\n{\n\n  \nnumber1\n:\n \n1234\n,\n\n  \n__thing\n:\n \n{\n\n    \nstring\n:\n \nhi\n,\n\n    \nsymbol\n:\n \n:hi\n\n  \n}\n\n\n}\n\n\n\n\n\nNotice that the Symbol keys do not \nstart\n with a colon, because the colon is instead placed \nafter\n the name.\n\n\nGenerally, Maps do \nnot\n put a space between the braces and the entries of the Map, but \ndoes\n include a space between each entry. This is to avoid ambiguities with other braced constructs that we'll see later on.\n\n\nIt's possible to use other types of values as keys for Maps, which we'll see later on, but the preference is to always use Symbols. Earlier, we saw how Symbols can be compared efficiently as Integers which makes their use as Map keys very effective. Using other types will generally slow down performance.\n\n\nA final note on collections: nesting is not limited to the same type. It's just as easy to create Lists of Maps or Maps of Lists. For example:\n\n\n[\n\n  \n{\na\n:\n \n1\n,\n \nb\n:\n \n2\n},\n\n  \n{\na\n:\n \n3\n,\n \nb\n:\n \n4\n}\n\n\n]\n\n\n\n\n\nVariables\n\n\nVariables are names that store values. For the most part, any value can be assigned to any variable at any time.\n\n\nAll variable names in Myst are \nidentifiers\n. An identifier is any series of letters, numbers, and/or underscores, with the restriction that the first character can not be a number. The casing and structure of the name determines it's \nkind\n.\n\n\nThere are three main kinds of variables in Myst - Locals, Underscores, and Constants - each with a specific purpose and use case.\n\n\nLocals\n\n\nLocal variables start with a lowercase alphabetic character and are generally written in \nsnake_case\n. Locals can be freely assigned and referenced any number of times, and are generally used to hold temporary data.\n\n\nFor example, when doing a complex calculation, intermediate results are generally held in local variables to make the final calculation more clear.\n\n\nLocal variables are tied to the \nlexical scope\n that they are created in. In other words, variables created within a block of code will be destroyed once the block of code is finished running.\n\n\nAll of the following are examples of valid local variable names:\n\n\nx\n\n\na\n\n\nsomething_longer\n\n\nnumber1\n\n\nnum_456\n\n\n\n\n\nUnderscores\n\n\nUnderscores are local variables that start with an ASCII underscore character, \n_\n.\n\n\nJust like locals, underscore variables can be assigned to and referenced any number of times. However, referencing an underscore variable will emit a warning.\n\n\nGenerally, underscores are used to indicate that a variable is known to exist, but should not be used in the code. We'll see examples of how this is helpful later on, namely with function parameters and pattern matching.\n\n\nIn some languages, there is a pattern of using a single underscore character to indicate that a value is unwanted. Some languages even treat the single underscore specially.\n\n\nOther languages, Myst included, treat all underscore variables equally. As such, it's often useful to provide a more descriptive name for the underscore variable in case it may become useful in the future.\n\n\nFor example, this code is entirely valid:\n\n\n[\nfirst_name\n,\n \n_\n,\n \n_\n,\n \n_\n]\n \n=\n \nsome_method\n\n\n\n\n\nWe'll cover exactly what this means later on, but it's obvious that there are three values we don't \ncurrently\n care about. The issue is that without looking at the definition of \nsome_method\n, it's hard to tell \nwhat\n those values are, and if they could be useful in the code that follows it.\n\n\nA better version of the above would be something like this:\n\n\n[\nfirst\n,\n \n_last\n,\n \n_age\n,\n \n_city\n]\n \n=\n \nsome_method\n\n\n\n\n\nHere, we can see what the other three values are, but they are still marked as undercsore variables, meaning we don't currently have a use for them.\n\n\nConstants\n\n\nConstants start with uppercase alphabetic characters, and are written either in \nUpperCamelCase\n, or \nSCREAMING_CASE\n. Constants also have different semantics than underscores and local variables.\n\n\nA constant variable can only be assigned once. Assigning to a constant more than once will raise an error. As such, constants are generally used to hold values that are not expected to change very often. For example, the seasons of a year:\n\n\nSEASONS\n \n=\n \n[\nspring\n,\n \nsummer\n,\n \nfall\n,\n \nwinter\n]\n\n\n\n\n\nNote that while the constant \nitself\n cannot be reassigned, its value may still be changed by other operations. For example, a new season could be added just by adding to the end of the list.\n\n\nSEASONS\n[\n4\n]\n \n=\n \nsome new season\n\n\n\n\n\nWe'll cover more about what this code means later on, but the important part here is that constants can still be modified, even though they can only be assigned once.\n\n\nThe other primary use of constants is to represent types and modules. Earlier in this section, you may have noticed that we always refer to the type of a value with a capital letter at the start. This is to match the name of the type within Myst. Types like \nInteger\n, \nFloat\n, and \nList\n are all constants within Myst.\n\n\nTypes and modules will be covered in more detail later on, but know for now that a variable written in \nUpperCamelCase\n is generally referring to either a type or a module.\n\n\nAssignments\n\n\nAssignments are the primary way of creating new variables. All assignments consist of a \ntarget\n (the left side), an assignment operator, and a \nvalue\n (the right side).\n\n\nSimple assignments\n\n\nMost assignments are technically \nsimple assignments\n. Myst also has two other kinds of assignments (\"match\" and \"operational\") with different semantics.\n\n\nA simple assignment is made with a variable name (called the \ntarget\n) followed by an equals sign (\n=\n) and then some value to be assigned. We've seen this a few times already, but here's a more complete example:\n\n\nx\n \n=\n \n1\n \n#=\n 1\n\n\nx\n     \n#=\n 1\n\n\nx\n \n=\n \n2\n \n#=\n 2\n\n\nx\n     \n#=\n 2\n\n\n\n\n\nThe comment on each line shows what the value of x is after the line has finished running.\n\n\nOperational assignments\n\n\nIt's fairly common for an assignment to include the target in the value being assigned. For example, incrementing a variable by one might look somtehing like this:\n\n\nx\n \n=\n \nx\n \n+\n \n1\n\n\n\n\n\nEspecially with longer variable names, the repetition of the name creates unnecessary noise and often makes the assignment harder to understand at a glance.\n\n\nTo improve this, Myst provides \noperational assignments\n, which include the operation being performed as part of the assignment operator. The above example could be written as an operational assignment like this:\n\n\nx\n \n+=\n \n1\n\n\n\n\n\nThe full semantics of operational assignments will be covered in the Basic Operations section.\n\n\nMatch assignments\n\n\nMatch assignments use the match operator (\n=:\n). Match assignments are unique in that an assignment will not necessarily occur. Instead, the \"assignment\" is an expectation about the \nvalue\n of the assignment, rather than the \ntarget\n.\n\n\nThe full semantics of match assignments will be covered later on in the Pattern Matching section.\n\n\nInterpolations\n\n\nOne of the truly unique features of Myst as a language is the ability to interpolate (or \ninject\n) any value into another other section of code. An interpolation is creating using angle braces (\n and \n) with some expression between them.\n\n\nIn the Maps section, we saw that Map keys are almost always Symbols, but that it's possible to use other values for keys as well. One way to do this is to use interpolations:\n\n\n{\n\n  \ntrue\n:\n       \n:true\n,\n\n  \nhello\n:\n    \n:string\n,\n\n  \n[\n1\n,\n \n2\n,\n \n3\n]\n:\n  \n:list\n\n\n}\n\n\n\n\n\nWith this syntax, it's possible to use \nany\n value as the key for a Map entry, even Lists or other Maps. But, as mentioned before, using keys other than Symbols will hinder performance.\n\n\nInterpolations also allow operations within the interpolation for even more powerful behavior. For example, variables can be referenced within an interpolation,and calls to other functions can be made:\n\n\nx\n \n=\n \n1\n\n\nlist\n \n=\n \n[\n1\n,\n \n2\n,\n \n3\n]\n\n\n{\n\n  \nx\n:\n \n:one\n,\n\n  \nlist\n[\n2\n]\n \n:three\n\n\n}\n\n\n\n\n\nIn fact, \nany\n expression can be used inside of an interpolation, but will require additional parentheses to avoid ambiguity with the less-than and greater-than operations:\n\n\nx\n \n=\n \n15\n\n\n{\n\n  \n(\n1\n \n+\n \n2\n)\n:\n \n:three\n,\n\n  \n(\nx\n \n/\n \n3\n)\n:\n \n:five\n\n\n}\n\n\n\n\n\nAll of the examples so far have shown interpolations used for creating keys in a Map. While interpolations are allowed anywhere in Myst code, they generally don't have any additional effects that make them useful. For example, these two lines are equivalent:\n\n\nx\n \n=\n \n(\n1\n \n+\n \n2\n)\n\n\nx\n \n=\n \n1\n \n+\n \n2\n\n\n\n\n\nAnother common use for interpolations is inside of Strings. In addition to evaluating an expression in-place, String interpolations will also convert the result into a String representation before inserting it into the String:\n\n\nname\n \n=\n \nJohn Smith\n\n\nhello, \n(name)\n!\n \n#=\n \nhello, John Smith!\n\n\n\n\n\nNote that string interpolations \nalways\n require the additional parentheses around the expression being interpolated.\n\n\nString interpolations are expanded by the language into separate components for the literal String parts and the expressions, then summed together to create the result. The exact expansion would look like this:\n\n\n# Given a string like this:\n\n\n1 + 2 = \n(1 + 2)\n!\n\n\n# The language would interpret it as:\n\n\n1 + 2 = \n \n+\n \n(\n1\n \n+\n \n2\n)\n.\nto_s\n \n+\n \n!\n\n\n\n\n\nThis expansion is \nsemantically\n the same as what the language ends up doing, but would perform slower than the interpolated version since the language can make some optimizations when the values are interpolated.\n\n\nThe last main use case of interpolations is in pattern matching, which we'll see later on in the Pattern Matching section.", 
            "title": "Values And Variables"
        }, 
        {
            "location": "/values_and_variables/#values-and-variables", 
            "text": "Myst is a strong, dynamically typed language. At a high level, \"strong\" means that every value has a specified type, and will retain that type unless explicitly told to change, and \"dynamic\" means that variables can hold any type of value at any time.  The exact meanings of \"strong\" and \"dynamic\" aren't entirely universal - people have varying ideas on the minor details - and can get surprisingly complex depending on how exact the definition is.  However, as with many other concepts, Myst implements a more pragmatic approach. Later on, we'll see that Myst provides a few different ways to restrict the types that variables can accept. For now though, \"strong\" and \"dynamic\" are sufficient descriptions of Myst's type system.", 
            "title": "Values And Variables"
        }, 
        {
            "location": "/values_and_variables/#value-literals", 
            "text": "Myst has a number of literal representations for values. These are the most basic way of creating new values in a program. Some examples of literals include:  nil             # Nil (`null` in some languages)  false           # Boolean  true            # Boolean  1               # Integer  1 . 0             # Float  hello         # String  :hello          # Symbol  [ 1 ,   2 ,   3 ]       # List  { a :   1 ,   b :   2 }    # Map   nil ,  false , and  true  are all  constant literals . That is, they always refer to the same object, and the same keyword is always used to refer to them. All other literals are mutable, in the sense that the exact representation can vary.", 
            "title": "Value Literals"
        }, 
        {
            "location": "/values_and_variables/#numerics", 
            "text": "Numerics are values that represent numbers. Myst supports Integers and Floats as numeric values.  An Integer is any whole number, such as  2 ,  100 , or  987654321 . Integer literals in Myst can also contain underscores to help separate groups of digits. This is particularly useful for large numbers. For example, compare these two representations of 1 billion:  11000000000  21_000_000_000   In the version with underscores, it's clear to see that there are 3 groups of  000 's, allowing someone reading the code to quickly see that the value is 1 billion.  Floats are real numbers that may contain decimal values, such as  1.0 ,  2.345 , or  123.456789 . Notice that  1.0  is a whole number, and thus technically an integer, but the representation as  1.0  indicates to Myst that the value is a Float. This relates to the strong typing mentioned above, where operations like division may behave differently based on the type of the operands.  As with Integers, underscores are allowed in Float literals, both before and after the decimal point:  123_456 . 789_0123   There is no restriction on how many underscores can be given in a literal, or that they have to form groups of 3. The following are all valid numeric literals, though they are generally avoided for consistency:  11_\n2100_00\n3255_._255\n41_2_3_4\n59_____9", 
            "title": "Numerics"
        }, 
        {
            "location": "/values_and_variables/#strings", 
            "text": "A String is any series of zero or more characters contained between two double quote ( ) characters. The following are all valid strings:  myst   hello, world!  1 + 2 == 3   All whitespace within a string is preserved, meaning Strings can span multiple lines:  hello,  world   Alternatively, this could be condensed using an escape sequence for the newline character:  hello, \\n world   Other escape sequences include tab characters ( \\t ), null terminators ( \\0 ), and a double quote within the string ( \\ ). If a String needs to contain the  \\  character itself, it must also be escaped to avoid ambiguity:  hi \\o    #=  The `\\` will escape the `o`.  hi  \\\\ o   #=  The String will contain a `\\` character.", 
            "title": "Strings"
        }, 
        {
            "location": "/values_and_variables/#symbols", 
            "text": "Symbols are similar to Strings, but with a different representation within the language that we'll cover soon.  A Symbol literal is a  name  or  identifier  prefixed with a colon. The following would all be interpreted as Symbols in Myst:  :hello  :two_words  :true  :false  :nil  :__with_some_underscores___  :numbers123   Additionally, Symbols can be created from a String literal the same way. This is useful for creating symbols with spaces in the name or with other special characters:  :    : hello, world  : +  :  /afs% 1234   Now, the way that Symbols are different than Strings is how they are stored within the language. Each Symbol is represented as an Integer. More importantly, every Symbol with the same name is represented by the  same  Integer. So, a Symbol,  :name , may be represented by the Integer  153 , then another Symbol,  :name , would also be represented by  153 .  This makes comparisons with Symbols extremely efficient (just comparing two integers, rather than each character in the name), which makes them great for cases where the name of the Symbol isn't necessarily important, but performance matters (such as Maps, as seen below).", 
            "title": "Symbols"
        }, 
        {
            "location": "/values_and_variables/#collections", 
            "text": "Apart from the individual literal types, Myst also has literal representations of two collection types: Lists and Maps. These are very common in Myst code, so it's important that they be easily and clearly represented.  A List is an ordered collection of values. Any combination of values can be added to a List. List literals are surrounded by square braces ( [  and  ] ), with each entry separated by a comma (and optionally some whitespace). All of the following are valid List literals:  []  [ 1 ]  [ 1 ,   2 ,   3 ]  [ nil ,   1 . 0 ,   hello ]  [ \n   1 ,   2 , \n   true ,   false , \n   hi ,   :hello  ]   Lists can also be nested within each other to create more complex structures:  [ \n   [ true ,   0 ] , \n   [ false ,   1 ,   2 ] , \n   [ \n     [ hi ,   []] , \n     [ :hello ,   nil ] \n   ]  ]   We'll see some more ways that Lists are useful in Myst later on.  A Map, on the other hand, is a collection of key-value pairs. In Myst, the order of the entries is also preserved. By default, all Map keys will be Symbols, but the value can be of any type.  A Map literal is created using curly braces ( {  and  } ), with comma-separated entries, similar to Lists. Each  entry  of a Map is written as a key name followed by a colon, followed by the value for that key. All of the following are valid Map literals:  {}  { a :   1 }  { a :   1 ,   b :   2 }  { true :   true ,   false :   false }  { \n   number1 :   1234 , \n   __thing :   { \n     string :   hi , \n     symbol :   :hi \n   }  }   Notice that the Symbol keys do not  start  with a colon, because the colon is instead placed  after  the name.  Generally, Maps do  not  put a space between the braces and the entries of the Map, but  does  include a space between each entry. This is to avoid ambiguities with other braced constructs that we'll see later on.  It's possible to use other types of values as keys for Maps, which we'll see later on, but the preference is to always use Symbols. Earlier, we saw how Symbols can be compared efficiently as Integers which makes their use as Map keys very effective. Using other types will generally slow down performance.  A final note on collections: nesting is not limited to the same type. It's just as easy to create Lists of Maps or Maps of Lists. For example:  [ \n   { a :   1 ,   b :   2 }, \n   { a :   3 ,   b :   4 }  ]", 
            "title": "Collections"
        }, 
        {
            "location": "/values_and_variables/#variables", 
            "text": "Variables are names that store values. For the most part, any value can be assigned to any variable at any time.  All variable names in Myst are  identifiers . An identifier is any series of letters, numbers, and/or underscores, with the restriction that the first character can not be a number. The casing and structure of the name determines it's  kind .  There are three main kinds of variables in Myst - Locals, Underscores, and Constants - each with a specific purpose and use case.", 
            "title": "Variables"
        }, 
        {
            "location": "/values_and_variables/#locals", 
            "text": "Local variables start with a lowercase alphabetic character and are generally written in  snake_case . Locals can be freely assigned and referenced any number of times, and are generally used to hold temporary data.  For example, when doing a complex calculation, intermediate results are generally held in local variables to make the final calculation more clear.  Local variables are tied to the  lexical scope  that they are created in. In other words, variables created within a block of code will be destroyed once the block of code is finished running.  All of the following are examples of valid local variable names:  x  a  something_longer  number1  num_456", 
            "title": "Locals"
        }, 
        {
            "location": "/values_and_variables/#underscores", 
            "text": "Underscores are local variables that start with an ASCII underscore character,  _ .  Just like locals, underscore variables can be assigned to and referenced any number of times. However, referencing an underscore variable will emit a warning.  Generally, underscores are used to indicate that a variable is known to exist, but should not be used in the code. We'll see examples of how this is helpful later on, namely with function parameters and pattern matching.  In some languages, there is a pattern of using a single underscore character to indicate that a value is unwanted. Some languages even treat the single underscore specially.  Other languages, Myst included, treat all underscore variables equally. As such, it's often useful to provide a more descriptive name for the underscore variable in case it may become useful in the future.  For example, this code is entirely valid:  [ first_name ,   _ ,   _ ,   _ ]   =   some_method   We'll cover exactly what this means later on, but it's obvious that there are three values we don't  currently  care about. The issue is that without looking at the definition of  some_method , it's hard to tell  what  those values are, and if they could be useful in the code that follows it.  A better version of the above would be something like this:  [ first ,   _last ,   _age ,   _city ]   =   some_method   Here, we can see what the other three values are, but they are still marked as undercsore variables, meaning we don't currently have a use for them.", 
            "title": "Underscores"
        }, 
        {
            "location": "/values_and_variables/#constants", 
            "text": "Constants start with uppercase alphabetic characters, and are written either in  UpperCamelCase , or  SCREAMING_CASE . Constants also have different semantics than underscores and local variables.  A constant variable can only be assigned once. Assigning to a constant more than once will raise an error. As such, constants are generally used to hold values that are not expected to change very often. For example, the seasons of a year:  SEASONS   =   [ spring ,   summer ,   fall ,   winter ]   Note that while the constant  itself  cannot be reassigned, its value may still be changed by other operations. For example, a new season could be added just by adding to the end of the list.  SEASONS [ 4 ]   =   some new season   We'll cover more about what this code means later on, but the important part here is that constants can still be modified, even though they can only be assigned once.  The other primary use of constants is to represent types and modules. Earlier in this section, you may have noticed that we always refer to the type of a value with a capital letter at the start. This is to match the name of the type within Myst. Types like  Integer ,  Float , and  List  are all constants within Myst.  Types and modules will be covered in more detail later on, but know for now that a variable written in  UpperCamelCase  is generally referring to either a type or a module.", 
            "title": "Constants"
        }, 
        {
            "location": "/values_and_variables/#assignments", 
            "text": "Assignments are the primary way of creating new variables. All assignments consist of a  target  (the left side), an assignment operator, and a  value  (the right side).", 
            "title": "Assignments"
        }, 
        {
            "location": "/values_and_variables/#simple-assignments", 
            "text": "Most assignments are technically  simple assignments . Myst also has two other kinds of assignments (\"match\" and \"operational\") with different semantics.  A simple assignment is made with a variable name (called the  target ) followed by an equals sign ( = ) and then some value to be assigned. We've seen this a few times already, but here's a more complete example:  x   =   1   #=  1  x       #=  1  x   =   2   #=  2  x       #=  2   The comment on each line shows what the value of x is after the line has finished running.", 
            "title": "Simple assignments"
        }, 
        {
            "location": "/values_and_variables/#operational-assignments", 
            "text": "It's fairly common for an assignment to include the target in the value being assigned. For example, incrementing a variable by one might look somtehing like this:  x   =   x   +   1   Especially with longer variable names, the repetition of the name creates unnecessary noise and often makes the assignment harder to understand at a glance.  To improve this, Myst provides  operational assignments , which include the operation being performed as part of the assignment operator. The above example could be written as an operational assignment like this:  x   +=   1   The full semantics of operational assignments will be covered in the Basic Operations section.", 
            "title": "Operational assignments"
        }, 
        {
            "location": "/values_and_variables/#match-assignments", 
            "text": "Match assignments use the match operator ( =: ). Match assignments are unique in that an assignment will not necessarily occur. Instead, the \"assignment\" is an expectation about the  value  of the assignment, rather than the  target .  The full semantics of match assignments will be covered later on in the Pattern Matching section.", 
            "title": "Match assignments"
        }, 
        {
            "location": "/values_and_variables/#interpolations", 
            "text": "One of the truly unique features of Myst as a language is the ability to interpolate (or  inject ) any value into another other section of code. An interpolation is creating using angle braces (  and  ) with some expression between them.  In the Maps section, we saw that Map keys are almost always Symbols, but that it's possible to use other values for keys as well. One way to do this is to use interpolations:  { \n   true :         :true , \n   hello :      :string , \n   [ 1 ,   2 ,   3 ] :    :list  }   With this syntax, it's possible to use  any  value as the key for a Map entry, even Lists or other Maps. But, as mentioned before, using keys other than Symbols will hinder performance.  Interpolations also allow operations within the interpolation for even more powerful behavior. For example, variables can be referenced within an interpolation,and calls to other functions can be made:  x   =   1  list   =   [ 1 ,   2 ,   3 ]  { \n   x :   :one , \n   list [ 2 ]   :three  }   In fact,  any  expression can be used inside of an interpolation, but will require additional parentheses to avoid ambiguity with the less-than and greater-than operations:  x   =   15  { \n   ( 1   +   2 ) :   :three , \n   ( x   /   3 ) :   :five  }   All of the examples so far have shown interpolations used for creating keys in a Map. While interpolations are allowed anywhere in Myst code, they generally don't have any additional effects that make them useful. For example, these two lines are equivalent:  x   =   ( 1   +   2 )  x   =   1   +   2   Another common use for interpolations is inside of Strings. In addition to evaluating an expression in-place, String interpolations will also convert the result into a String representation before inserting it into the String:  name   =   John Smith  hello,  (name) !   #=   hello, John Smith!   Note that string interpolations  always  require the additional parentheses around the expression being interpolated.  String interpolations are expanded by the language into separate components for the literal String parts and the expressions, then summed together to create the result. The exact expansion would look like this:  # Given a string like this:  1 + 2 =  (1 + 2) !  # The language would interpret it as:  1 + 2 =    +   ( 1   +   2 ) . to_s   +   !   This expansion is  semantically  the same as what the language ends up doing, but would perform slower than the interpolated version since the language can make some optimizations when the values are interpolated.  The last main use case of interpolations is in pattern matching, which we'll see later on in the Pattern Matching section.", 
            "title": "Interpolations"
        }
    ]
}